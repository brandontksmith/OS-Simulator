package os.simulator;

import java.util.LinkedList;

/**
 * This class mimics a Central Processing Unit (CPU) in an Operating System.
 * 
 * @author BTKS
 */
public class CPU {
    
    /**
     * A reference to the System Clock.
     */
    private Clock clock;
    
    /**
     * The process that is currently being processed by the CPU.
     */
    private PCB activeProcess;
    
    /**
     * Construct a new CPU.
     */
    public CPU() {
        this.clock = new Clock();
        this.activeProcess = null;
    }
    
    /**
     * Sets the currently active process on the CPU.
     * 
     * @param process process to hand to the CPU
     */
    public void setActiveProcess(PCB process) {
        this.activeProcess = process;
        
        if (activeProcess == null) {
            return;
        }
        
        // set the time the process arrived
        if (!activeProcess.isArrived()) {
            activeProcess.setArrived(true);
            activeProcess.setArrival(getClock().getClock());
        }
        
        // if process has not started yet, set that it has now been started
        if (!activeProcess.isStarted()) {
            activeProcess.setStarted(true);
        }
        
        // currently active process should have a RUN state
        activeProcess.setState(ProcessState.RUN);
    }
    
    /**
     * Advances the Operating System by one cycle.
     */
    public void advanceClock() {
        clock.execute();;
        
        // detect any interrupts (aka interrupts generated by I/O)
        detectInterrupt();
        
        if (activeProcess != null) {
            String instructionName = activeProcess.getCurrentInstruction();
            activeProcess.setBurst(activeProcess.getBurst() - 1);
            activeProcess.setCPUTime(activeProcess.getCPUTime() + 1);
            
            switch (instructionName) {
                case "CALCULATE":
                    break;
                
                case "I/O":
                    activeProcess.setState(ProcessState.WAIT);
                    activeProcess.setWaitingIO(true);
                    
                    OS.scheduler.getWaitingQueue().enQueue(activeProcess);
                    OS.ioScheduler.scheduleIO(activeProcess, clock.getClock());
                    
                    break;
                
                case "YIELD":
                    detectPreemption();
                    
                    break;
                
                case "OUT":
                    String processStr = activeProcess.toString();
                    String processStrForConsole;
                    
                    processStrForConsole = "Received by System\n\n" + processStr;
                    
                    System.out.println(processStr);
                    
                    OSSimulator.desktop.addTextToConsole(processStrForConsole);
                    
                    break;
            }
            
            activeProcess.setInstructionCycles(activeProcess.getInstructionCycles() - 1);
            
            if (activeProcess.getBurst() == 0) {
                activeProcess.setFinished(true);
                activeProcess.setState(ProcessState.EXIT);
                
                OS.memoryManager.deallocateMemory(activeProcess.getMemoryAllocated());
            }
        } else {
            System.out.println("No Process Running @ " + clock.getClock());
        }
    }
    
    /**
     * Detects interrupts generated by the Interrupt Processor.
     */
    public void detectInterrupt() {
        LinkedList<ECB> events = OS.interruptProcessor.signalInterrupt(clock.getClock());
        
        while (!events.isEmpty()) {
            ECB event = events.poll();
            PCB process = event.getProcess();
            
            if (process.isFinished()) {
                continue;
            }
            
            process.setWaitingIO(false);
            process.incrementIoComplete();
            process.setState(ProcessState.READY);
            
            OS.scheduler.removePCB(process, true);            
            OS.scheduler.insertPCB(process, false);
        }
    }
    
    /**
     * Detects when a process is preempted and removed from the CPU.
     */
    public void detectPreemption() {
        OS.scheduler.resetTimeRemaining();
    }
    
    /**
     * Returns the System Clock.
     */
    public Clock getClock() {
        return clock;
    }

    /**
     * Sets the System Clock.
     * 
     * @param clock the system clock
     */
    public void setClock(Clock clock) {
        this.clock = clock;
    }
    
    /**
     * Returns the Active Process.
     */
    public PCB getActiveProcess() {
        return activeProcess;
    }
}